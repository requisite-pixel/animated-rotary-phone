<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>Secure Notes (Telegram CloudStorage)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <!-- Bootstrap (–ø—Ä–æ—Å—Ç–∞—è UI, –±–µ–∑ —ç—Ñ—Ñ–µ–∫—Ç–æ–≤) -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/css/bootstrap.min.css" rel="stylesheet">
  <script defer src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.3/dist/js/bootstrap.bundle.min.js"></script>

  <style>
    body { background:#f7f7fb; }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; }
    #notesList .list-group-item { cursor:pointer; }
    #editor { min-height: 55vh; resize: vertical; }
    .small-muted { font-size: 12px; color: #6c757d; }
  </style>
</head>
<body>
<div class="container py-3">

  <div class="d-flex align-items-center justify-content-between gap-2 mb-3">
    <div>
      <div class="fw-bold">üîê Secure Notes Vault</div>
      <div class="small-muted">AES-GCM ¬∑ –æ–¥–∏–Ω –ø–∞—Ä–æ–ª—å (–Ω–µ —Ö—Ä–∞–Ω–∏—Ç—Å—è) ¬∑ CloudStorage 1024 keys / 4KB value</div>
    </div>
    <div class="d-flex gap-2 flex-wrap">
      <button id="btnLock" class="btn btn-outline-secondary btn-sm" disabled>Lock</button>
      <button id="btnClear" class="btn btn-outline-danger btn-sm">–°—Ç–µ—Ä–µ—Ç—å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ</button>
    </div>
  </div>

  <!-- Alerts -->
  <div id="alertBox"></div>

  <!-- Unlock card -->
  <div id="unlockCard" class="card mb-3">
    <div class="card-body">
      <div class="row g-2 align-items-end">
        <div class="col-12 col-md-8">
          <label class="form-label">–ü–∞—Ä–æ–ª—å</label>
          <input id="pw" type="password" class="form-control" placeholder="–í–≤–µ–¥–∏—Ç–µ –ø–∞—Ä–æ–ª—å‚Ä¶" autocomplete="current-password">
          <div class="small-muted mt-1">–ü–∞—Ä–æ–ª—å –Ω–∏–≥–¥–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è. –ï—Å–ª–∏ –∑–∞–±—É–¥–µ—à—å ‚Äî –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.</div>
        </div>
        <div class="col-12 col-md-4 d-grid">
          <button id="btnUnlock" class="btn btn-primary">Unblock</button>
        </div>
      </div>
    </div>
  </div>

  <!-- Main app -->
  <div id="app" class="row g-3 d-none">
    <!-- Left: notes -->
    <div class="col-12 col-lg-4">
      <div class="card h-100">
        <div class="card-body">
          <div class="d-flex gap-2 mb-2">
            <input id="q" class="form-control form-control-sm" placeholder="–ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é‚Ä¶" />
            <span id="usagePill" class="badge text-bg-light border mono" title="–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–æ –∫–ª—é—á–µ–π">‚Äî</span>
          </div>

          <div class="d-flex gap-2 flex-wrap mb-2">
            <button id="btnNew" class="btn btn-success btn-sm">New</button>
            <button id="btnRename" class="btn btn-outline-primary btn-sm" disabled>Rename</button>
            <button id="btnDelete" class="btn btn-outline-danger btn-sm" disabled>Delete</button>
          </div>

          <div id="notesList" class="list-group" style="max-height: 60vh; overflow:auto;"></div>

          <div class="small-muted mt-2">
            ‚ö†Ô∏è –ê–≤—Ç–æ—Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –Ω–µ—Ç (—á—Ç–æ–±—ã –Ω–µ –Ω–∞–≥—Ä—É–∂–∞—Ç—å —Å–µ—Ä–≤–µ—Ä). –°–æ—Ö—Ä–∞–Ω—è–π –≤—Ä—É—á–Ω—É—é.
          </div>
        </div>
      </div>
    </div>

    <!-- Right: editor -->
    <div class="col-12 col-lg-8">
      <div class="card h-100">
        <div class="card-body d-flex flex-column gap-2">
          <div class="d-flex align-items-start justify-content-between gap-2 flex-wrap">
            <div>
              <div class="fw-semibold" id="activeTitle">‚Äî</div>
              <div class="small-muted" id="activeMeta">‚Äî</div>
            </div>
            <div class="d-flex gap-2 align-items-center flex-wrap">
              <span class="mono small-muted" id="byteInfo">0 B</span>
              <span class="badge text-bg-light border mono" id="chunkInfo">‚Äî</span>
              <button id="btnSave" class="btn btn-primary btn-sm" disabled>Save</button>
            </div>
          </div>

          <textarea id="editor" class="form-control" placeholder="–û—Ç–∫—Ä–æ–π –∏–ª–∏ —Å–æ–∑–¥–∞–π –∑–∞–º–µ—Ç–∫—É‚Ä¶" disabled></textarea>

          <!-- Saving bar -->
          <div id="savingBar" class="d-none">
            <div class="d-flex align-items-center gap-2">
              <div class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></div>
              <div class="small-muted" id="savingText">–°–æ—Ö—Ä–∞–Ω—è—é‚Ä¶</div>
            </div>
            <div class="progress mt-2">
              <div id="savingProg" class="progress-bar" role="progressbar" style="width: 0%"></div>
            </div>
          </div>

          <div class="small-muted">
            –ì–æ—Ä—è—á–∞—è –∫–ª–∞–≤–∏—à–∞: <span class="mono">Ctrl+S</span>
          </div>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Modal: input (new/rename) -->
<div class="modal fade" id="inputModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <form class="modal-content" id="inputForm">
      <div class="modal-header">
        <h5 class="modal-title" id="inputModalTitle">‚Ä¶</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body">
        <label class="form-label" id="inputLabel">–ù–∞–∑–≤–∞–Ω–∏–µ</label>
        <input id="inputValue" class="form-control" />
        <div class="small-muted mt-2" id="inputHint"></div>
      </div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="submit" class="btn btn-primary" id="inputOk">OK</button>
      </div>
    </form>
  </div>
</div>

<!-- Modal: confirm -->
<div class="modal fade" id="confirmModal" tabindex="-1" aria-hidden="true">
  <div class="modal-dialog">
    <div class="modal-content">
      <div class="modal-header">
        <h5 class="modal-title" id="confirmTitle">–ü–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∏–µ</h5>
        <button type="button" class="btn-close" data-bs-dismiss="modal" aria-label="Close"></button>
      </div>
      <div class="modal-body" id="confirmText">‚Ä¶</div>
      <div class="modal-footer">
        <button type="button" class="btn btn-outline-secondary" data-bs-dismiss="modal">Cancel</button>
        <button type="button" class="btn btn-danger" id="confirmYes">Yes</button>
      </div>
    </div>
  </div>
</div>

<script>
/* =========================
   Telegram CloudStorage + fallback
   ========================= */
const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
if (tg) { try { tg.ready(); tg.expand(); } catch(_){} }

const CLOUD_MAX_KEYS = 1024;
const VALUE_MAX_BYTES = 4096;

// plaintext chunk size (safe to fit into 4KB after AES-GCM + base64 + JSON)
const MAX_PLAINTEXT_CHUNK_BYTES = 2500;

// rate limit: 10 chunk-saves per second
const SETITEM_MIN_INTERVAL_MS = 110;

// prefix
const P = "cs1_";
const K_SALT = P + "salt";
const K_META = P + "meta";

// keys:
// index chunk: cs1_i_r{rev}_c{i}
// note chunk:  cs1_n{ID}_r{rev}_c{i}
function kIndexChunk(rev, i){ return `${P}i_r${rev}_c${i}`; }
function kNoteChunk(id, rev, i){ return `${P}n${id}_r${rev}_c${i}`; }

function hasCloud() {
  return tg && tg.CloudStorage && typeof tg.CloudStorage.getItem === "function";
}
function byteLen(str){ return new TextEncoder().encode(str).length; }
function fmtBytes(n){
  const u=["B","KB","MB","GB"]; let i=0,x=n;
  while (x>=1024 && i<u.length-1){ x/=1024; i++; }
  return (i===0? String(x|0) : x.toFixed(2))+" "+u[i];
}

/* ===== Alerts ===== */
const alertBox = document.getElementById("alertBox");
function showAlert(type, text){
  const div = document.createElement("div");
  div.className = `alert alert-${type} py-2`;
  div.textContent = text;
  alertBox.appendChild(div);
  setTimeout(()=>div.remove(), 4500);
}

/* ===== Cloud wrappers ===== */
let lastSetAt = 0;
async function rateLimit(){
  const now = Date.now();
  const wait = lastSetAt + SETITEM_MIN_INTERVAL_MS - now;
  if (wait > 0) await new Promise(r => setTimeout(r, wait));
  lastSetAt = Date.now();
}

function cloudSetRaw(key, value){
  return new Promise((res)=>{
    if (!hasCloud()){
      const s = String(value ?? "");
      if (byteLen(s) > VALUE_MAX_BYTES) return res({ok:false, err:"VALUE_TOO_LARGE"});
      localStorage.setItem(key, s);
      return res({ok:true});
    }
    tg.CloudStorage.setItem(key, value, (err)=>res({ok:!err, err:err||null}));
  });
}
async function cloudSet(key, value){
  await rateLimit(); // enforce 10 saves/sec
  return cloudSetRaw(key, value);
}
function cloudGet(key){
  return new Promise((res)=>{
    if (!hasCloud()) return res(localStorage.getItem(key) ?? "");
    tg.CloudStorage.getItem(key, (_e,v)=>res(v ?? ""));
  });
}
function cloudRemove(key){
  return new Promise((res)=>{
    if (!hasCloud()){ localStorage.removeItem(key); return res(true); }
    tg.CloudStorage.removeItem(key, ()=>res(true));
  });
}
function cloudKeys(){
  return new Promise((res)=>{
    if (!hasCloud()){
      const keys=[]; for (let i=0;i<localStorage.length;i++){ const k=localStorage.key(i); if(k) keys.push(k); }
      return res(keys);
    }
    tg.CloudStorage.getKeys((_e, keys)=>res(keys||[]));
  });
}

/* =========================
   Crypto (WebCrypto)
   ========================= */
let vaultKey = null;
let unlocked = false;

function u8ToB64(u8){
  let bin=""; const chunk=0x8000;
  for (let i=0;i<u8.length;i+=chunk) bin += String.fromCharCode(...u8.subarray(i,i+chunk));
  return btoa(bin);
}
function b64ToU8(b64){
  const bin=atob(b64); const u8=new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) u8[i]=bin.charCodeAt(i);
  return u8;
}

async function getOrCreateSalt(){
  const s = await cloudGet(K_SALT);
  if (s) return b64ToU8(s);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const r = await cloudSet(K_SALT, u8ToB64(salt));
  if (!r.ok) throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å salt");
  return salt;
}

async function deriveKeyFromPassword(password, salt){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey("raw", enc.encode(password), "PBKDF2", false, ["deriveKey"]);
  return crypto.subtle.deriveKey(
    { name:"PBKDF2", salt, iterations:200000, hash:"SHA-256" },
    baseKey,
    { name:"AES-GCM", length:256 },
    false,
    ["encrypt","decrypt"]
  );
}

async function encryptBytes(plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, vaultKey, plainU8);
  return { v:1, iv:u8ToB64(iv), ct:u8ToB64(new Uint8Array(ct)) };
}

async function decryptToBytes(obj){
  const iv = b64ToU8(obj.iv);
  const ct = b64ToU8(obj.ct);
  const pt = await crypto.subtle.decrypt({name:"AES-GCM", iv}, vaultKey, ct);
  return new Uint8Array(pt);
}

/* =========================
   Chunking & verified save/load
   ========================= */
function chunkBytes(u8, maxBytes){
  const out=[];
  for (let i=0;i<u8.length;i+=maxBytes) out.push(u8.subarray(i,i+maxBytes));
  return out;
}

async function saveEncryptedSingle(key, bytes){
  const obj = await encryptBytes(bytes);
  const value = JSON.stringify(obj);
  if (byteLen(value) > VALUE_MAX_BYTES) return {ok:false, err:"VALUE_TOO_LARGE"};
  const r = await cloudSet(key, value);
  if (!r.ok) return {ok:false, err:r.err || "SET_FAILED"};
  // verification
  const rb = await cloudGet(key);
  if (rb !== value) return {ok:false, err:"READBACK_MISMATCH"};
  return {ok:true};
}

async function loadEncryptedSingle(key){
  const s = await cloudGet(key);
  if (!s) return null;
  const obj = JSON.parse(s);
  return decryptToBytes(obj);
}

async function saveBlob(prefixKeyFn, rev, bytes, onProgress){
  const chunks = chunkBytes(bytes, MAX_PLAINTEXT_CHUNK_BYTES);
  const total = chunks.length;

  for (let i=0;i<total;i++){
    const obj = await encryptBytes(chunks[i]);
    const value = JSON.stringify(obj);

    if (byteLen(value) > VALUE_MAX_BYTES) throw new Error("–ß–∞–Ω–∫ –Ω–µ –≤–ª–µ–∑ –≤ 4KB. –£–º–µ–Ω—å—à–∏ MAX_PLAINTEXT_CHUNK_BYTES.");

    const k = prefixKeyFn(rev, i);
    const r = await cloudSet(k, value);
    if (!r.ok) throw new Error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —á–∞–Ω–∫–∞ "+i);

    // verification (–æ–±—è–∑–∞—Ç–µ–ª—å–Ω–æ –ø–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º)
    const rb = await cloudGet(k);
    if (rb !== value) throw new Error("Readback mismatch –Ω–∞ —á–∞–Ω–∫–µ "+i);

    if (onProgress) onProgress(i+1, total);
  }
  return total;
}

async function loadBlob(prefixKeyFn, rev, chunkCount){
  const parts=[];
  for (let i=0;i<chunkCount;i++){
    const s = await cloudGet(prefixKeyFn(rev,i));
    if (!s) throw new Error("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —á–∞–Ω–∫ "+i);
    const obj = JSON.parse(s);
    parts.push(await decryptToBytes(obj));
  }
  let total=0; for (const p of parts) total += p.length;
  const merged = new Uint8Array(total);
  let off=0; for (const p of parts){ merged.set(p, off); off += p.length; }
  return merged;
}

async function deleteBlob(prefixKeyFn, rev, chunkCount){
  for (let i=0;i<chunkCount;i++){
    await cloudRemove(prefixKeyFn(rev,i));
  }
}

/* =========================
   Vault model
   ========================= */
let meta = null;
// meta: { metaRev, indexRev, indexChunks }
let index = { version:1, nextId:1, notes:[] };
// note entry: {id,title,updated,rev,chunks,bytes}

async function loadMeta(){
  const pt = await loadEncryptedSingle(K_META);
  if (!pt) return null;
  return JSON.parse(new TextDecoder().decode(pt));
}

async function saveMeta(m){
  const bytes = new TextEncoder().encode(JSON.stringify(m));
  const r = await saveEncryptedSingle(K_META, bytes);
  if (!r.ok) throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å meta: "+r.err);
}

async function loadIndex(){
  if (!meta || !meta.indexRev) return {version:1,nextId:1,notes:[]};
  const bytes = await loadBlob((rev,i)=>kIndexChunk(rev,i), meta.indexRev, meta.indexChunks);
  const idx = JSON.parse(new TextDecoder().decode(bytes));
  if (!idx || idx.version !== 1) throw new Error("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –≤–µ—Ä—Å–∏—è –∏–Ω–¥–µ–∫—Å–∞");
  return idx;
}

async function saveIndexTransactional(idx){
  // 1) save new index rev
  const oldRev = meta.indexRev || 0;
  const oldChunks = meta.indexChunks || 0;
  const newRev = (meta.indexRev || 0) + 1;

  const bytes = new TextEncoder().encode(JSON.stringify(idx));
  const newChunks = await saveBlob((rev,i)=>kIndexChunk(rev,i), newRev, bytes, null);

  // 2) save meta to point to new index
  const newMeta = { ...meta, metaRev:(meta.metaRev||0)+1, indexRev:newRev, indexChunks:newChunks };
  await saveMeta(newMeta);
  meta = newMeta;

  // 3) delete old index chunks
  if (oldRev && oldChunks) await deleteBlob((rev,i)=>kIndexChunk(rev,i), oldRev, oldChunks);
}

/* =========================
   UI state
   ========================= */
const unlockCard = document.getElementById("unlockCard");
const app = document.getElementById("app");
const pw = document.getElementById("pw");
const btnUnlock = document.getElementById("btnUnlock");
const btnLock = document.getElementById("btnLock");
const btnClear = document.getElementById("btnClear");

const q = document.getElementById("q");
const notesList = document.getElementById("notesList");
const usagePill = document.getElementById("usagePill");

const btnNew = document.getElementById("btnNew");
const btnRename = document.getElementById("btnRename");
const btnDelete = document.getElementById("btnDelete");

const activeTitle = document.getElementById("activeTitle");
const activeMeta = document.getElementById("activeMeta");
const editor = document.getElementById("editor");
const btnSave = document.getElementById("btnSave");
const byteInfo = document.getElementById("byteInfo");
const chunkInfo = document.getElementById("chunkInfo");

const savingBar = document.getElementById("savingBar");
const savingText = document.getElementById("savingText");
const savingProg = document.getElementById("savingProg");

let activeId = null;
let isSaving = false;

function setSaving(on, text="–°–æ—Ö—Ä–∞–Ω—è—é‚Ä¶", done=0, total=1){
  isSaving = on;
  savingBar.classList.toggle("d-none", !on);
  savingText.textContent = text;
  const pct = total ? Math.round((done/total)*100) : 0;
  savingProg.style.width = pct + "%";

  // disable buttons while saving
  btnSave.disabled = on || !activeId;
  btnNew.disabled = on;
  btnRename.disabled = on || !activeId;
  btnDelete.disabled = on || !activeId;
  btnLock.disabled = on || !unlocked;
  btnClear.disabled = on;
  editor.disabled = on || !activeId || !unlocked;
  q.disabled = on || !unlocked;
}

function setUnlockedUI(on){
  unlocked = on;
  unlockCard.classList.toggle("d-none", on);
  app.classList.toggle("d-none", !on);
  btnLock.disabled = !on;
  q.disabled = !on;
  btnNew.disabled = !on;
  btnRename.disabled = !on || !activeId;
  btnDelete.disabled = !on || !activeId;
  btnSave.disabled = !on || !activeId;
  editor.disabled = !on || !activeId;
}

function updateEditorStats(){
  const bytes = new TextEncoder().encode(editor.value).length;
  byteInfo.textContent = fmtBytes(bytes);
  const estChunks = Math.max(1, Math.ceil(bytes / MAX_PLAINTEXT_CHUNK_BYTES));
  chunkInfo.textContent = `Est: ${estChunks} chunks`;
}

async function refreshUsage(){
  const keys = (await cloudKeys()).filter(k=>k.startsWith(P));
  usagePill.textContent = `${keys.length}/${CLOUD_MAX_KEYS}`;
}

function renderNotes(){
  const term = q.value.trim().toLowerCase();
  notesList.innerHTML = "";

  const items = index.notes
    .slice()
    .sort((a,b)=>(b.updated||0)-(a.updated||0))
    .filter(n => !term || (n.title||"").toLowerCase().includes(term));

  if (items.length === 0){
    const div = document.createElement("div");
    div.className = "text-muted small";
    div.textContent = "–ù–µ—Ç –∑–∞–º–µ—Ç–æ–∫. –ù–∞–∂–º–∏ New.";
    notesList.appendChild(div);
    return;
  }

  for (const n of items){
    const a = document.createElement("a");
    a.className = "list-group-item list-group-item-action";
    if (n.id === activeId) a.classList.add("active");

    const dt = n.updated ? new Date(n.updated).toLocaleString() : "‚Äî";
    a.innerHTML = `
      <div class="d-flex w-100 justify-content-between">
        <div class="fw-semibold">${escapeHtml(n.title || ("Note "+n.id))}</div>
        <small class="mono">#${n.id}</small>
      </div>
      <div class="small-muted">${fmtBytes(n.bytes||0)} ¬∑ ${n.chunks||0} chunks ¬∑ ${dt}</div>
    `;
    a.onclick = (e)=>{ e.preventDefault(); openNote(n.id); };
    notesList.appendChild(a);
  }
}

function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

/* =========================
   Modals
   ========================= */
const inputModalEl = document.getElementById("inputModal");
const inputModal = new bootstrap.Modal(inputModalEl);
const inputForm = document.getElementById("inputForm");
const inputModalTitle = document.getElementById("inputModalTitle");
const inputValue = document.getElementById("inputValue");
const inputHint = document.getElementById("inputHint");
let inputResolve = null;

function askText(title, initialValue, hint){
  inputModalTitle.textContent = title;
  inputValue.value = initialValue || "";
  inputHint.textContent = hint || "";
  inputModal.show();
  setTimeout(()=>inputValue.focus(), 0);
  return new Promise((res)=>{ inputResolve = res; });
}
inputForm.addEventListener("submit", (e)=>{
  e.preventDefault();
  const v = inputValue.value;
  inputModal.hide();
  if (inputResolve) inputResolve(v);
  inputResolve = null;
});
inputModalEl.addEventListener("hidden.bs.modal", ()=>{
  if (inputResolve){ inputResolve(null); inputResolve=null; }
});

const confirmModalEl = document.getElementById("confirmModal");
const confirmModal = new bootstrap.Modal(confirmModalEl);
const confirmTitle = document.getElementById("confirmTitle");
const confirmText = document.getElementById("confirmText");
const confirmYes = document.getElementById("confirmYes");
let confirmResolve = null;

function askConfirm(title, text, yesLabel="Yes"){
  confirmTitle.textContent = title;
  confirmText.textContent = text;
  confirmYes.textContent = yesLabel;
  confirmModal.show();
  return new Promise((res)=>{ confirmResolve = res; });
}
confirmYes.onclick = ()=>{
  confirmModal.hide();
  if (confirmResolve) confirmResolve(true);
  confirmResolve = null;
};
confirmModalEl.addEventListener("hidden.bs.modal", ()=>{
  if (confirmResolve){ confirmResolve(false); confirmResolve=null; }
});

/* =========================
   Actions
   ========================= */
async function doUnlock(){
  const password = pw.value;
  if (!password || password.length < 4){
    showAlert("warning", "–ü–∞—Ä–æ–ª—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π.");
    return;
  }
  try{
    const salt = await getOrCreateSalt();
    vaultKey = await deriveKeyFromPassword(password, salt);

    let m = await loadMeta().catch(()=>null);
    if (!m){
      // init new vault
      meta = { metaRev:1, indexRev:1, indexChunks:1 };
      index = { version:1, nextId:1, notes:[] };

      // save index rev=1
      const idxBytes = new TextEncoder().encode(JSON.stringify(index));
      const chunks = await saveBlob((rev,i)=>kIndexChunk(rev,i), 1, idxBytes, null);
      meta.indexChunks = chunks;

      await saveMeta(meta);
      showAlert("success", "–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π vault.");
    } else {
      meta = m;
      index = await loadIndex();
      showAlert("success", `Vault —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω. –ó–∞–º–µ—Ç–æ–∫: ${index.notes.length}`);
    }

    activeId = null;
    activeTitle.textContent = "‚Äî";
    activeMeta.textContent = "‚Äî";
    editor.value = "";
    updateEditorStats();

    setUnlockedUI(true);
    renderNotes();
    await refreshUsage();

  }catch(e){
    vaultKey = null;
    meta = null;
    index = {version:1,nextId:1,notes:[]};
    showAlert("danger", "–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –∏–ª–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω—ã.");
    console.error(e);
  }
}

function doLock(){
  vaultKey = null;
  meta = null;
  index = {version:1,nextId:1,notes:[]};
  activeId = null;
  editor.value = "";
  activeTitle.textContent = "‚Äî";
  activeMeta.textContent = "‚Äî";
  setUnlockedUI(false);
  showAlert("secondary", "Locked.");
}

async function openNote(id){
  if (!unlocked || isSaving) return;
  const n = index.notes.find(x=>x.id===id);
  if (!n) return;

  try{
    const bytes = await loadBlob((rev,i)=>kNoteChunk(id,rev,i), n.rev, n.chunks);
    editor.value = new TextDecoder().decode(bytes);
    activeId = id;

    activeTitle.textContent = n.title || ("Note "+id);
    activeMeta.textContent = `#${id} ¬∑ ${fmtBytes(n.bytes||0)} ¬∑ ${n.chunks} chunks ¬∑ rev ${n.rev}`;

    btnRename.disabled = false;
    btnDelete.disabled = false;
    btnSave.disabled = false;
    editor.disabled = false;

    updateEditorStats();
    renderNotes();
  }catch(e){
    showAlert("danger", "–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–º–µ—Ç–∫—É: " + (e.message||e));
  }
}

async function createNote(){
  if (!unlocked || isSaving) return;
  const title = await askText("New note", "New note", "–ù–∞–∑–≤–∞–Ω–∏–µ –º–æ–∂–Ω–æ –ø–æ–º–µ–Ω—è—Ç—å –ø–æ–∑–∂–µ.");
  if (title === null) return;

  const usedKeys = (await cloudKeys()).filter(k=>k.startsWith(P)).length;
  if (usedKeys + 1 > CLOUD_MAX_KEYS){
    showAlert("warning", "–ù–µ—Ç –º–µ—Å—Ç–∞ (–∫–ª—é—á–µ–π) –¥–ª—è –Ω–æ–≤–æ–π –∑–∞–º–µ—Ç–∫–∏.");
    return;
  }

  const id = index.nextId++;
  const now = Date.now();
  const note = { id, title: (title.trim() || ("Note "+id)), updated: now, rev:1, chunks:1, bytes:0 };

  try{
    // save empty
    setSaving(true, "–°–æ—Ö—Ä–∞–Ω—è—é (—Å–æ–∑–¥–∞–Ω–∏–µ)‚Ä¶", 0, 1);
    const bytes = new Uint8Array(0);
    const chunks = await saveBlob((rev,i)=>kNoteChunk(id,rev,i), 1, bytes, (done,total)=>{
      setSaving(true, `–°–æ—Ö—Ä–∞–Ω—è—é (—Å–æ–∑–¥–∞–Ω–∏–µ)‚Ä¶ ${done}/${total}`, done, total);
    });
    note.chunks = chunks;
    note.bytes = 0;

    index.notes.push(note);
    await saveIndexTransactional(index);

    setSaving(false);
    showAlert("success", "–ó–∞–º–µ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∞.");
    await refreshUsage();
    renderNotes();
    await openNote(id);
  }catch(e){
    setSaving(false);
    showAlert("danger", "–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å: " + (e.message||e));
  }
}

async function renameNote(){
  if (!unlocked || !activeId || isSaving) return;
  const n = index.notes.find(x=>x.id===activeId);
  if (!n) return;

  const title = await askText("Rename", n.title || ("Note "+n.id), "");
  if (title === null) return;

  n.title = title.trim() || ("Note "+n.id);
  n.updated = Date.now();

  try{
    setSaving(true, "–°–æ—Ö—Ä–∞–Ω—è—é (–ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–∏–µ)‚Ä¶", 0, 1);
    await saveIndexTransactional(index);
    setSaving(false);

    activeTitle.textContent = n.title;
    showAlert("success", "–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ.");
    renderNotes();
  }catch(e){
    setSaving(false);
    showAlert("danger", "–û—à–∏–±–∫–∞: " + (e.message||e));
  }
}

async function deleteNote(){
  if (!unlocked || !activeId || isSaving) return;
  const n = index.notes.find(x=>x.id===activeId);
  if (!n) return;

  const ok = await askConfirm("Delete note", `–£–¥–∞–ª–∏—Ç—å "${n.title}"?`, "Delete");
  if (!ok) return;

  try{
    setSaving(true, "–£–¥–∞–ª—è—é‚Ä¶", 0, 1);
    await deleteBlob((rev,i)=>kNoteChunk(n.id,rev,i), n.rev, n.chunks);

    index.notes = index.notes.filter(x=>x.id!==n.id);
    await saveIndexTransactional(index);

    activeId = null;
    editor.value = "";
    editor.disabled = true;
    btnRename.disabled = true;
    btnDelete.disabled = true;
    btnSave.disabled = true;

    activeTitle.textContent = "‚Äî";
    activeMeta.textContent = "‚Äî";
    setSaving(false);

    showAlert("success", "–£–¥–∞–ª–µ–Ω–æ.");
    await refreshUsage();
    renderNotes();
  }catch(e){
    setSaving(false);
    showAlert("danger", "–û—à–∏–±–∫–∞ —É–¥–∞–ª–µ–Ω–∏—è: " + (e.message||e));
  }
}

async function saveNote(){
  if (!unlocked || !activeId || isSaving) return;
  const n = index.notes.find(x=>x.id===activeId);
  if (!n) return;

  const text = editor.value;
  const bytes = new TextEncoder().encode(text);
  const needChunks = Math.max(1, Math.ceil(bytes.length / MAX_PLAINTEXT_CHUNK_BYTES));

  // space check (peak keys)
  const usedKeys = (await cloudKeys()).filter(k=>k.startsWith(P)).length;
  const peak = usedKeys + needChunks; // new rev chunks allocated before deleting old
  if (peak > CLOUD_MAX_KEYS){
    showAlert("warning", `–ù–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è: –º–∞–ª–æ –º–µ—Å—Ç–∞. Peak = ${peak}/${CLOUD_MAX_KEYS} keys.`);
    return;
  }

  try{
    const newRev = (n.rev || 0) + 1;

    setSaving(true, `–°–æ—Ö—Ä–∞–Ω—è—é‚Ä¶ 0/${needChunks}`, 0, needChunks);

    const newChunkCount = await saveBlob(
      (rev,i)=>kNoteChunk(n.id,rev,i),
      newRev,
      bytes,
      (done,total)=>setSaving(true, `–°–æ—Ö—Ä–∞–Ω—è—é‚Ä¶ ${done}/${total}`, done, total)
    );

    // update index -> then delete old revision
    const oldRev = n.rev, oldChunks = n.chunks;

    n.rev = newRev;
    n.chunks = newChunkCount;
    n.bytes = bytes.length;
    n.updated = Date.now();

    setSaving(true, "–°–æ—Ö—Ä–∞–Ω—è—é –∏–Ω–¥–µ–∫—Å‚Ä¶", 1, 1);
    await saveIndexTransactional(index);

    // cleanup old note chunks
    if (oldRev && oldChunks){
      setSaving(true, "–£–¥–∞–ª—è—é —Å—Ç–∞—Ä—É—é —Ä–µ–≤–∏–∑–∏—é‚Ä¶", 1, 1);
      await deleteBlob((rev,i)=>kNoteChunk(n.id,rev,i), oldRev, oldChunks);
    }

    setSaving(false);
    activeMeta.textContent = `#${n.id} ¬∑ ${fmtBytes(n.bytes||0)} ¬∑ ${n.chunks} chunks ¬∑ rev ${n.rev}`;
    showAlert("success", "–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ (—Å –ø—Ä–æ–≤–µ—Ä–∫–æ–π).");
    await refreshUsage();
    renderNotes();

  }catch(e){
    setSaving(false);
    showAlert("danger", "–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è: " + (e.message||e));
  }
}

async function clearVault(){
  if (isSaving) return;
  const ok = await askConfirm("–°—Ç–µ—Ä–µ—Ç—å —Ö—Ä–∞–Ω–∏–ª–∏—â–µ", "–£–¥–∞–ª–∏—Ç—å –í–°–ï –∫–ª—é—á–∏ cs1_*? –≠—Ç–æ –Ω–µ–æ–±—Ä–∞—Ç–∏–º–æ.", "–°—Ç–µ—Ä–µ—Ç—å");
  if (!ok) return;

  try{
    setSaving(true, "–°—Ç–∏—Ä–∞—é‚Ä¶", 0, 1);
    const keys = (await cloudKeys()).filter(k=>k.startsWith(P));
    for (const k of keys){
      await cloudRemove(k);
    }
    setSaving(false);
    doLock();
    showAlert("success", "–•—Ä–∞–Ω–∏–ª–∏—â–µ –æ—á–∏—â–µ–Ω–æ.");
  }catch(e){
    setSaving(false);
    showAlert("danger", "–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏: " + (e.message||e));
  }
}

/* =========================
   Wire
   ========================= */
btnUnlock.onclick = doUnlock;
pw.addEventListener("keydown", (e)=>{ if (e.key === "Enter") doUnlock(); });

btnLock.onclick = doLock;
btnClear.onclick = clearVault;

btnNew.onclick = createNote;
btnRename.onclick = renameNote;
btnDelete.onclick = deleteNote;
btnSave.onclick = saveNote;

q.addEventListener("input", renderNotes);
editor.addEventListener("input", updateEditorStats);

document.addEventListener("keydown", (e)=>{
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase() === "s"){
    e.preventDefault();
    if (unlocked && activeId && !isSaving) saveNote();
  }
});

(async ()=>{
  if (!hasCloud()){
    showAlert("warning", "CloudStorage –Ω–µ –Ω–∞–π–¥–µ–Ω ‚Äî –≤–∫–ª—é—á—ë–Ω fallback –Ω–∞ localStorage (—Ç–æ–ª—å–∫–æ –¥–ª—è —Ç–µ—Å—Ç–∞ –≤ –±—Ä–∞—É–∑–µ—Ä–µ).");
  }
  await refreshUsage().catch(()=>{});
})();
</script>
</body>
</html>
