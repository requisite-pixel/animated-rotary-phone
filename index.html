<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <title>üîê Secure Notes Vault (Telegram CloudStorage)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />

  <script src="https://telegram.org/js/telegram-web-app.js"></script>

  <style>
    :root{
      --bg: #0b0f19;
      --panel:#0f172a;
      --panel2:#111c33;
      --text:#e6eaf2;
      --muted:#a7b0c4;
      --line:#24314f;
      --accent:#7c5cff;
      --accent2:#3dd6d0;
      --danger:#ff4d6d;
      --ok:#2dd4bf;
      --warn:#fbbf24;

      --r: 18px;
      --shadow: 0 12px 40px rgba(0,0,0,.35);
      --mono: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
      --sans: system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, Noto Sans, Arial, sans-serif;
    }
    @media (prefers-color-scheme: light){
      :root{
        --bg:#f6f7fb; --panel:#ffffff; --panel2:#fbfbff; --text:#0b1020; --muted:#66708a; --line:#e5e9f5;
        --shadow: 0 10px 30px rgba(30,50,110,.12);
      }
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: var(--sans);
      background: radial-gradient(1200px 800px at 15% 0%, rgba(124,92,255,.18), transparent 60%),
                  radial-gradient(1000px 700px at 95% 20%, rgba(61,214,208,.14), transparent 55%),
                  var(--bg);
      color:var(--text);
    }

    .app{
      height:100%;
      display:flex;
      flex-direction:column;
      gap:12px;
      padding:14px;
      max-width:1200px;
      margin:0 auto;
    }

    header{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      padding:12px 14px;
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }
    .brand{
      display:flex; align-items:center; gap:10px;
      min-width:0;
    }
    .logo{
      width:34px; height:34px; border-radius:12px;
      background:
        radial-gradient(14px 14px at 30% 30%, rgba(255,255,255,.9), transparent 60%),
        linear-gradient(135deg, var(--accent), var(--accent2));
      box-shadow: 0 8px 18px rgba(124,92,255,.28);
      flex:0 0 auto;
    }
    .brand h1{
      font-size:14px;
      margin:0;
      letter-spacing:.3px;
      line-height:1.1;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }
    .brand .sub{
      font-size:12px;
      color:var(--muted);
      margin-top:2px;
      white-space:nowrap;
      overflow:hidden;
      text-overflow:ellipsis;
    }

    .top-actions{display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end}
    button, .btn{
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color:var(--text);
      padding:9px 11px;
      border-radius: 12px;
      cursor:pointer;
      font-weight:600;
      transition: transform .06s ease, background .2s ease, border-color .2s ease;
      user-select:none;
    }
    button:hover{background: rgba(255,255,255,.07); border-color: rgba(124,92,255,.35)}
    button:active{transform: translateY(1px)}
    button.primary{
      background: linear-gradient(135deg, rgba(124,92,255,.95), rgba(61,214,208,.75));
      border-color: transparent;
      color: white;
    }
    button.danger{border-color: rgba(255,77,109,.35); background: rgba(255,77,109,.10)}
    button.ghost{background: transparent}
    button:disabled{opacity:.45; cursor:not-allowed; transform:none}

    .main{
      display:grid;
      grid-template-columns: 340px 1fr;
      gap:12px;
      min-height:0;
      flex:1 1 auto;
    }
    @media (max-width: 920px){
      .main{grid-template-columns: 1fr; grid-template-rows: 340px 1fr}
    }

    .panel{
      min-height:0;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
      border:1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      overflow:hidden;
      display:flex;
      flex-direction:column;
    }
    .panel .hd{
      padding:12px 12px 10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:8px;
      border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.06);
    }
    .panel .hd .title{
      font-size:13px;
      color: var(--muted);
      font-weight:700;
      letter-spacing:.3px;
      text-transform:uppercase;
    }
    .panel .bd{padding:12px; min-height:0; overflow:auto}

    .search{
      display:flex; gap:8px; align-items:center; padding:10px 12px; border-bottom:1px solid var(--line);
      background: rgba(0,0,0,.03);
    }
    input[type="text"], input[type="password"], textarea{
      width:100%;
      border:1px solid var(--line);
      background: rgba(255,255,255,.04);
      color: var(--text);
      padding:10px 11px;
      border-radius: 12px;
      outline:none;
      transition:border-color .2s ease, box-shadow .2s ease;
    }
    input:focus, textarea:focus{
      border-color: rgba(124,92,255,.55);
      box-shadow: 0 0 0 3px rgba(124,92,255,.18);
    }

    .notes{
      padding:8px;
      display:flex;
      flex-direction:column;
      gap:8px;
    }
    .note-item{
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      border-radius: 14px;
      padding:10px 10px;
      cursor:pointer;
      display:flex;
      align-items:flex-start;
      justify-content:space-between;
      gap:10px;
    }
    .note-item:hover{border-color: rgba(124,92,255,.35); background: rgba(255,255,255,.05)}
    .note-item.active{
      border-color: rgba(124,92,255,.6);
      background: linear-gradient(180deg, rgba(124,92,255,.14), rgba(255,255,255,.03));
    }
    .note-item .t{
      font-weight:800;
      font-size:14px;
      line-height:1.2;
      margin:0 0 4px;
      max-width:220px;
      overflow:hidden;
      text-overflow:ellipsis;
      white-space:nowrap;
    }
    .note-item .m{
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      flex-wrap:wrap;
    }
    .pill{
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      padding:4px 8px;
      border-radius:999px;
      font-size:12px;
      color:var(--muted);
      white-space:nowrap;
    }

    .editor-top{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
    }
    .editor-top .grow{flex:1 1 auto; min-width:160px}
    .editor-title{
      font-weight:800;
      letter-spacing:.2px;
    }

    textarea#editor{
      width:100%;
      min-height: 320px;
      height: 100%;
      resize:none;
      font-family: var(--sans);
      line-height:1.45;
      padding:12px 12px;
      border-radius: 16px;
    }

    .statusbar{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:10px 12px;
      border-top:1px solid var(--line);
      background: rgba(0,0,0,.04);
      font-size:12px;
      color:var(--muted);
    }
    .statusbar .left, .statusbar .right{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .kbd{
      font-family: var(--mono);
      padding:2px 6px;
      border-radius: 8px;
      border:1px solid var(--line);
      background: rgba(255,255,255,.03);
      color: var(--muted);
    }

    .toast{
      position: fixed;
      left: 14px;
      bottom: 14px;
      display:flex;
      flex-direction:column;
      gap:8px;
      z-index: 1000;
      pointer-events:none;
    }
    .toast .t{
      pointer-events:none;
      max-width: min(560px, calc(100vw - 28px));
      border:1px solid var(--line);
      background: rgba(16, 24, 40, .78);
      color: var(--text);
      padding:10px 12px;
      border-radius: 14px;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      font-size:13px;
      display:flex;
      gap:10px;
      align-items:flex-start;
    }
    .toast .t small{display:block; color:var(--muted); margin-top:2px}
    .tag-ok{color: var(--ok)}
    .tag-warn{color: var(--warn)}
    .tag-bad{color: var(--danger)}

    /* Lock modal */
    .modal{
      position: fixed;
      inset: 0;
      background: rgba(0,0,0,.55);
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 2000;
      padding: 14px;
    }
    .modal.on{display:flex}
    .modal .card{
      width: min(520px, 100%);
      border:1px solid var(--line);
      border-radius: 22px;
      background: linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
      box-shadow: var(--shadow);
      overflow:hidden;
    }
    .modal .card .chd{
      padding: 14px 14px 10px;
      border-bottom:1px solid var(--line);
      display:flex; align-items:center; justify-content:space-between; gap:10px;
    }
    .modal .card .chd h2{margin:0; font-size:15px}
    .modal .card .cbd{padding:14px}
    .modal .hint{font-size:12px; color:var(--muted); margin-top:8px; line-height:1.4}
    .row{display:flex; gap:10px; align-items:center; flex-wrap:wrap}
    .row > *{flex:1 1 auto}
    .row .tight{flex: 0 0 auto}

    .muted{color:var(--muted)}
    .mono{font-family:var(--mono)}
    .hidden{display:none !important}
  </style>
</head>
<body>
<div class="app">
  <header>
    <div class="brand">
      <div class="logo"></div>
      <div style="min-width:0">
        <h1>Secure Notes Vault</h1>
        <div class="sub">Telegram CloudStorage ¬∑ AES-GCM ¬∑ –ø–∞—Ä–æ–ª—å –Ω–µ —Ö—Ä–∞–Ω–∏—Ç—Å—è</div>
      </div>
    </div>

    <div class="top-actions">
      <button id="btnUnlock" class="primary">üîì Unblock</button>
      <button id="btnLock" class="ghost" disabled>üîí Lock</button>
      <button id="btnNew" disabled>‚ûï New</button>
      <button id="btnRename" disabled>‚úèÔ∏è Rename</button>
      <button id="btnDelete" class="danger" disabled>üóëÔ∏è Delete</button>
      <button id="btnExport" disabled>‚¨áÔ∏è Export</button>
      <button id="btnClear" class="danger">‚ö†Ô∏è Clear vault</button>
    </div>
  </header>

  <div class="main">
    <section class="panel" id="leftPanel">
      <div class="hd">
        <div class="title">Notes</div>
        <div class="pill" id="pillUsage">‚Äî</div>
      </div>
      <div class="search">
        <input id="q" type="text" placeholder="Search by title‚Ä¶" disabled />
      </div>
      <div class="bd" style="padding:0">
        <div class="notes" id="notes"></div>
      </div>
    </section>

    <section class="panel">
      <div class="hd">
        <div class="title">Editor</div>
        <div class="pill" id="pillState">Locked</div>
      </div>
      <div class="bd" style="display:flex; flex-direction:column; gap:10px; min-height:0">
        <div class="editor-top">
          <div class="grow">
            <div class="editor-title" id="activeTitle">‚Äî</div>
            <div class="muted" id="activeMeta" style="font-size:12px; margin-top:2px">Unlock to view notes.</div>
          </div>
          <button id="btnSave" class="primary" disabled>üíæ Save</button>
        </div>

        <textarea id="editor" placeholder="‚Ä¶" disabled></textarea>
      </div>
      <div class="statusbar">
        <div class="left">
          <span id="statusText">Locked.</span>
          <span class="kbd">Ctrl</span><span class="kbd">S</span>
          <span class="muted">to save</span>
        </div>
        <div class="right">
          <span id="byteInfo" class="mono">0 B</span>
          <span class="pill" id="chunkInfo">‚Äî</span>
        </div>
      </div>
    </section>
  </div>
</div>

<!-- Lock / Unlock modal -->
<div class="modal" id="lockModal">
  <div class="card">
    <div class="chd">
      <h2>üîê Unblock vault</h2>
      <button id="btnCloseModal" class="ghost">‚úï</button>
    </div>
    <div class="cbd">
      <div class="row">
        <input id="pw" type="password" placeholder="–ü–∞—Ä–æ–ª—å‚Ä¶" autocomplete="current-password" />
        <button id="btnDoUnlock" class="primary tight">Unblock</button>
      </div>
      <div class="hint">
        <div>–ü–∞—Ä–æ–ª—å –Ω–∏–≥–¥–µ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è–µ—Ç—Å—è. –û–Ω –Ω—É–∂–µ–Ω —Ç–æ–ª—å–∫–æ –¥–ª—è derivation –∫–ª—é—á–∞ (PBKDF2) –∏ —Ä–∞—Å—à–∏—Ñ—Ä–æ–≤–∫–∏.</div>
        <div class="muted">–ï—Å–ª–∏ –ø–æ—Ç–µ—Ä—è–µ—à—å –ø–∞—Ä–æ–ª—å ‚Äî –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –∑–∞–ø–∏—Å–∏ –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ.</div>
      </div>
      <div class="hint" id="unlockHint"></div>
    </div>
  </div>
</div>

<div class="toast" id="toast"></div>

<script>
/* =========================
   Telegram CloudStorage + fallback
   ========================= */
const tg = (window.Telegram && window.Telegram.WebApp) ? window.Telegram.WebApp : null;
if (tg) { try { tg.ready(); tg.expand(); } catch(_){} }

const CLOUD_MAX_KEYS = 1024;
const VALUE_MAX_BYTES = 4096;

// IMPORTANT: —ç—Ç–æ "–±–µ–∑–æ–ø–∞—Å–Ω–∞—è" –º–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è –¥–ª–∏–Ω–∞ plaintext-—á–∞–Ω–∫–∞ –≤ –±–∞–π—Ç–∞—Ö.
// –° —É—á—ë—Ç–æ–º AES-GCM (+16), base64 (~4/3) –∏ JSON-–æ–±—ë—Ä—Ç–∫–∏ ‚Äî –¥–æ–ª–∂–Ω–æ —Å—Ç–∞–±–∏–ª—å–Ω–æ –≤–ª–µ–∑–∞—Ç—å –≤ 4096 –±–∞–π—Ç.
const MAX_PLAINTEXT_CHUNK_BYTES = 2800;

// –ü—Ä–µ—Ñ–∏–∫—Å –Ω–∞—à–∏—Ö –∫–ª—é—á–µ–π, —á—Ç–æ–±—ã –Ω–µ –º–µ—à–∞—Ç—å –¥—Ä—É–≥–∏–º –¥–∞–Ω–Ω—ã–º.
const P = "cs1_";

// –ö–ª—é—á–∏:
// - cs1_salt : base64(salt) (–ù–ï –∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω)
// - cs1_meta : encrypted({metaRev, indexRev, indexChunks}) (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω)
// - cs1_i_r{rev}_c{n} : index chunks (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã)
// - cs1_n{ID}_r{rev}_c{n} : note chunks (–∑–∞—à–∏—Ñ—Ä–æ–≤–∞–Ω—ã)
const K_SALT = P + "salt";
const K_META = P + "meta";

function hasCloud() {
  return tg && tg.CloudStorage && typeof tg.CloudStorage.getItem === "function";
}
function byteLen(str){ return new TextEncoder().encode(str).length; }
function fmtBytes(n){
  const units = ["B","KB","MB","GB"];
  let i=0, x=n;
  while (x>=1024 && i<units.length-1){ x/=1024; i++; }
  return (i===0? String(x|0) : x.toFixed(2)) + " " + units[i];
}

function cloudSet(key, value){
  return new Promise((res) => {
    if (!hasCloud()){
      // fallback: localStorage with same constraints
      const s = String(value ?? "");
      if (byteLen(s) > VALUE_MAX_BYTES) return res({ok:false, err:"VALUE_TOO_LARGE"});
      localStorage.setItem(key, s);
      return res({ok:true});
    }
    tg.CloudStorage.setItem(key, value, (err) => res({ok:!err, err: err || null}));
  });
}
function cloudGet(key){
  return new Promise((res) => {
    if (!hasCloud()){
      return res(localStorage.getItem(key) ?? "");
    }
    tg.CloudStorage.getItem(key, (_err, v) => res(v ?? ""));
  });
}
function cloudRemove(key){
  return new Promise((res) => {
    if (!hasCloud()){
      localStorage.removeItem(key);
      return res(true);
    }
    tg.CloudStorage.removeItem(key, () => res(true));
  });
}
function cloudKeys(){
  return new Promise((res) => {
    if (!hasCloud()){
      const keys = [];
      for (let i=0;i<localStorage.length;i++){
        const k = localStorage.key(i);
        if (k) keys.push(k);
      }
      return res(keys);
    }
    tg.CloudStorage.getKeys((_err, keys) => res(keys || []));
  });
}

/* =========================
   Crypto helpers (WebCrypto)
   ========================= */
let vaultKey = null;   // CryptoKey (AES-GCM)
let unlocked = false;

function u8ToB64(u8){
  let bin = "";
  const chunk = 0x8000;
  for (let i=0; i<u8.length; i+=chunk){
    bin += String.fromCharCode(...u8.subarray(i, i+chunk));
  }
  return btoa(bin);
}
function b64ToU8(b64){
  const bin = atob(b64);
  const u8 = new Uint8Array(bin.length);
  for (let i=0;i<bin.length;i++) u8[i] = bin.charCodeAt(i);
  return u8;
}

async function getOrCreateSalt(){
  let s = await cloudGet(K_SALT);
  if (s) return b64ToU8(s);
  const salt = crypto.getRandomValues(new Uint8Array(16));
  const ok = await cloudSet(K_SALT, u8ToB64(salt));
  if (!ok.ok) throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å salt");
  return salt;
}

async function deriveKeyFromPassword(password, salt){
  const enc = new TextEncoder();
  const baseKey = await crypto.subtle.importKey(
    "raw",
    enc.encode(password),
    "PBKDF2",
    false,
    ["deriveKey"]
  );

  // –ò—Ç–µ—Ä–∞—Ü–∏–∏ –º–æ–∂–Ω–æ –ø–æ–≤—ã—à–∞—Ç—å. 200k –æ–±—ã—á–Ω–æ –æ–∫ –¥–ª—è WebApp.
  const iterations = 200000;

  return crypto.subtle.deriveKey(
    {
      name: "PBKDF2",
      salt,
      iterations,
      hash: "SHA-256"
    },
    baseKey,
    { name: "AES-GCM", length: 256 },
    false,
    ["encrypt","decrypt"]
  );
}

async function encryptBytes(plainU8){
  const iv = crypto.getRandomValues(new Uint8Array(12));
  const ct = await crypto.subtle.encrypt({name:"AES-GCM", iv}, vaultKey, plainU8);
  return {
    v: 1,
    iv: u8ToB64(iv),
    ct: u8ToB64(new Uint8Array(ct))
  };
}
async function decryptToBytes(obj){
  const iv = b64ToU8(obj.iv);
  const ct = b64ToU8(obj.ct);
  const pt = await crypto.subtle.decrypt({name:"AES-GCM", iv}, vaultKey, ct);
  return new Uint8Array(pt);
}

function chunkBytes(u8, maxBytes){
  const out = [];
  for (let i=0; i<u8.length; i+=maxBytes){
    out.push(u8.subarray(i, i+maxBytes));
  }
  return out;
}

/* =========================
   Vault data model
   ========================= */
let meta = null;
// meta: { metaRev:number, indexRev:number, indexChunks:number }
// index (encrypted): { version:1, nextId:number, notes:[{id,title,updated,rev,chunks,bytes}] }

function kIndexChunk(rev, i){ return `${P}i_r${rev}_c${i}`; }
function kNoteChunk(id, rev, i){ return `${P}n${id}_r${rev}_c${i}`; }

async function loadEncryptedSingle(key){
  const s = await cloudGet(key);
  if (!s) return null;
  const obj = JSON.parse(s);
  const pt = await decryptToBytes(obj);
  return pt;
}
async function saveEncryptedSingle(key, bytes, verify=true){
  const obj = await encryptBytes(bytes);
  const value = JSON.stringify(obj);
  if (byteLen(value) > VALUE_MAX_BYTES) return {ok:false, err:"VALUE_TOO_LARGE"};
  const r1 = await cloudSet(key, value);
  if (!r1.ok) return {ok:false, err:r1.err || "SET_FAILED"};
  if (verify){
    const rb = await cloudGet(key);
    if (rb !== value) return {ok:false, err:"READBACK_MISMATCH"};
  }
  return {ok:true};
}

async function loadBlob(prefixKeyFn, rev, chunkCount){
  const parts = [];
  for (let i=0; i<chunkCount; i++){
    const s = await cloudGet(prefixKeyFn(rev, i));
    if (!s) throw new Error("–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç —á–∞–Ω–∫: " + i);
    const obj = JSON.parse(s);
    const pt = await decryptToBytes(obj);
    parts.push(pt);
  }
  let total = 0;
  for (const p of parts) total += p.length;
  const merged = new Uint8Array(total);
  let off = 0;
  for (const p of parts){ merged.set(p, off); off += p.length; }
  return merged;
}

async function saveBlob(prefixKeyFn, newRev, bytes, verify=true){
  const chunks = chunkBytes(bytes, MAX_PLAINTEXT_CHUNK_BYTES);
  for (let i=0; i<chunks.length; i++){
    const obj = await encryptBytes(chunks[i]);
    const value = JSON.stringify(obj);
    if (byteLen(value) > VALUE_MAX_BYTES) {
      throw new Error("–ß–∞–Ω–∫ –Ω–µ –≤–ª–µ–∑ –≤ 4KB (—É–º–µ–Ω—å—à–∏ MAX_PLAINTEXT_CHUNK_BYTES).");
    }
    const r = await cloudSet(prefixKeyFn(newRev, i), value);
    if (!r.ok) throw new Error("–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —á–∞–Ω–∫–∞ " + i);
    if (verify){
      const rb = await cloudGet(prefixKeyFn(newRev, i));
      if (rb !== value) throw new Error("Readback mismatch –Ω–∞ —á–∞–Ω–∫–µ " + i);
    }
  }
  return chunks.length;
}

async function deleteBlob(prefixKeyFn, rev, chunkCount){
  for (let i=0; i<chunkCount; i++){
    await cloudRemove(prefixKeyFn(rev, i));
  }
}

async function loadMeta(){
  const pt = await loadEncryptedSingle(K_META);
  if (!pt) return null;
  const txt = new TextDecoder().decode(pt);
  return JSON.parse(txt);
}

async function saveMeta(m){
  const bytes = new TextEncoder().encode(JSON.stringify(m));
  const r = await saveEncryptedSingle(K_META, bytes, true);
  if (!r.ok) throw new Error("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å meta: " + r.err);
}

async function loadIndex(){
  if (!meta || !meta.indexRev) {
    return { version:1, nextId: 1, notes: [] };
  }
  if (meta.indexChunks === 0) return { version:1, nextId: 1, notes: [] };
  const bytes = await loadBlob((rev,i)=>kIndexChunk(rev,i), meta.indexRev, meta.indexChunks);
  const txt = new TextDecoder().decode(bytes);
  const idx = JSON.parse(txt);
  if (!idx || idx.version !== 1) throw new Error("–ù–µ–ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ–º–∞—è –≤–µ—Ä—Å–∏—è –∏–Ω–¥–µ–∫—Å–∞");
  return idx;
}

async function saveIndexTransactional(idx, verify=true){
  // write new index rev, update meta, delete old
  const oldRev = meta.indexRev || 0;
  const oldChunks = meta.indexChunks || 0;
  const newRev = (meta.indexRev || 0) + 1;

  const bytes = new TextEncoder().encode(JSON.stringify(idx));
  const newChunkCount = await saveBlob((rev,i)=>kIndexChunk(rev,i), newRev, bytes, verify);

  const newMeta = {...meta, metaRev: (meta.metaRev||0)+1, indexRev: newRev, indexChunks: newChunkCount};
  await saveMeta(newMeta);
  meta = newMeta;

  // cleanup old
  if (oldRev && oldChunks) await deleteBlob((rev,i)=>kIndexChunk(rev,i), oldRev, oldChunks);
}

/* =========================
   UI + App logic
   ========================= */
const el = (id)=>document.getElementById(id);
const toastBox = el("toast");
function toast(kind, msg, detail=""){
  const div = document.createElement("div");
  div.className = "t";
  const tag =
    kind==="ok" ? "<b class='tag-ok'>‚úì</b>" :
    kind==="warn" ? "<b class='tag-warn'>!</b>" :
    "<b class='tag-bad'>√ó</b>";
  div.innerHTML = `${tag}<div><div>${escapeHtml(msg)}</div>${detail?`<small>${escapeHtml(detail)}</small>`:""}</div>`;
  toastBox.appendChild(div);
  setTimeout(()=>{ div.style.opacity="0"; div.style.transform="translateY(6px)"; }, 3200);
  setTimeout(()=>{ div.remove(); }, 3800);
}
function escapeHtml(s){
  return String(s).replace(/[&<>"']/g, m => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]));
}

let index = { version:1, nextId:1, notes:[] };
let activeId = null;
let dirty = false;
let autosaveTimer = null;

function setLockedUI(isUnlocked){
  unlocked = isUnlocked;
  el("pillState").textContent = isUnlocked ? "Unlocked" : "Locked";
  el("btnUnlock").disabled = isUnlocked;
  el("btnLock").disabled = !isUnlocked;
  el("btnNew").disabled = !isUnlocked;
  el("btnRename").disabled = !isUnlocked || !activeId;
  el("btnDelete").disabled = !isUnlocked || !activeId;
  el("btnSave").disabled = !isUnlocked || !activeId;
  el("btnExport").disabled = !isUnlocked;
  el("q").disabled = !isUnlocked;
  el("editor").disabled = !isUnlocked || !activeId;
  el("statusText").textContent = isUnlocked ? "Ready." : "Locked.";
  if (!isUnlocked){
    el("activeTitle").textContent = "‚Äî";
    el("activeMeta").textContent = "Unlock to view notes.";
    el("editor").value = "";
    el("byteInfo").textContent = "0 B";
    el("chunkInfo").textContent = "‚Äî";
  }
}

async function refreshUsagePill(){
  const keys = (await cloudKeys()).filter(k => k.startsWith(P));
  const used = keys.length;
  el("pillUsage").textContent = `${used}/${CLOUD_MAX_KEYS} keys`;
}

function renderNotes(){
  const q = el("q").value.trim().toLowerCase();
  const list = el("notes");
  list.innerHTML = "";

  const notes = index.notes
    .slice()
    .sort((a,b)=> (b.updated||0) - (a.updated||0))
    .filter(n => !q || (n.title||"").toLowerCase().includes(q));

  if (notes.length === 0){
    const empty = document.createElement("div");
    empty.style.padding = "12px";
    empty.style.color = "var(--muted)";
    empty.innerHTML = unlocked
      ? "–ù–µ—Ç –∑–∞–º–µ—Ç–æ–∫. –ù–∞–∂–º–∏ <b>New</b>."
      : "Locked.";
    list.appendChild(empty);
    return;
  }

  for (const n of notes){
    const div = document.createElement("div");
    div.className = "note-item" + (n.id===activeId ? " active" : "");
    const dt = n.updated ? new Date(n.updated) : null;
    const meta = [
      `<span class="pill">${fmtBytes(n.bytes||0)}</span>`,
      `<span class="pill">${n.chunks||0} chunks</span>`,
      dt ? `<span class="pill">${dt.toLocaleString()}</span>` : `<span class="pill">‚Äî</span>`
    ].join(" ");
    div.innerHTML = `
      <div style="min-width:0">
        <div class="t">${escapeHtml(n.title||("Note "+n.id))}</div>
        <div class="m">${meta}</div>
      </div>
      <div class="pill">#${n.id}</div>
    `;
    div.onclick = ()=>openNote(n.id);
    list.appendChild(div);
  }
}

function updateEditorInfo(){
  const txt = el("editor").value;
  const bytes = new TextEncoder().encode(txt).length;
  el("byteInfo").textContent = fmtBytes(bytes);

  const chunks = Math.max(1, Math.ceil(bytes / MAX_PLAINTEXT_CHUNK_BYTES));
  el("chunkInfo").textContent = `Est: ${chunks} chunks`;
}

function markDirty(v){
  dirty = v;
  el("statusText").textContent = !unlocked ? "Locked." : (dirty ? "Unsaved changes‚Ä¶" : "Saved.");
}

function startAutosave(){
  if (autosaveTimer) clearInterval(autosaveTimer);
  autosaveTimer = setInterval(async ()=>{
    if (unlocked && activeId && dirty){
      await saveActiveNote(true);
    }
  }, 1500);
}

async function openNote(id){
  if (!unlocked) return;
  if (dirty && activeId){
    // best effort: autosave before switching
    await saveActiveNote(true);
  }

  const n = index.notes.find(x=>x.id===id);
  if (!n) return;

  // load note blob
  try{
    const bytes = await loadBlob((rev,i)=>kNoteChunk(id, rev, i), n.rev, n.chunks);
    const txt = new TextDecoder().decode(bytes);
    activeId = id;
    el("activeTitle").textContent = n.title || ("Note " + id);
    el("activeMeta").textContent = `#${id} ¬∑ ${fmtBytes(n.bytes||0)} ¬∑ ${n.chunks} chunks ¬∑ rev ${n.rev}`;
    el("editor").value = txt;
    el("editor").disabled = false;
    el("btnSave").disabled = false;
    el("btnRename").disabled = false;
    el("btnDelete").disabled = false;
    markDirty(false);
    updateEditorInfo();
    renderNotes();
  }catch(e){
    toast("bad","–ù–µ —É–¥–∞–ª–æ—Å—å –æ—Ç–∫—Ä—ã—Ç—å –∑–∞–º–µ—Ç–∫—É", String(e.message||e));
  }
}

async function createNewNote(){
  const title = prompt("–ù–∞–∑–≤–∞–Ω–∏–µ –∑–∞–º–µ—Ç–∫–∏:", "New note");
  if (title === null) return;
  const id = index.nextId++;
  const now = Date.now();
  const note = { id, title: title.trim() || ("Note "+id), updated: now, rev: 1, chunks: 1, bytes: 0 };

  // save empty content
  try{
    // space check (peak usage)
    const usedKeys = (await cloudKeys()).filter(k=>k.startsWith(P)).length;
    // new note will allocate at least 1 chunk
    if (usedKeys + 1 > CLOUD_MAX_KEYS){
      toast("warn","–ù–µ —Ö–≤–∞—Ç–∞–µ—Ç –∫–ª—é—á–µ–π","–°–ª–∏—à–∫–æ–º –º–∞–ª–æ —Å–≤–æ–±–æ–¥–Ω–æ–≥–æ –º–µ—Å—Ç–∞ –≤ CloudStorage (1024 keys).");
      return;
    }

    const bytes = new Uint8Array(0);
    const chunks = await saveBlob((rev,i)=>kNoteChunk(id, rev, i), 1, bytes, true);
    note.chunks = chunks;
    note.bytes = 0;

    index.notes.push(note);
    await saveIndexTransactional(index, true);

    toast("ok","–ó–∞–º–µ—Ç–∫–∞ —Å–æ–∑–¥–∞–Ω–∞", `#${id}`);
    await refreshUsagePill();
    renderNotes();
    await openNote(id);
  }catch(e){
    toast("bad","–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å", String(e.message||e));
  }
}

async function renameActive(){
  if (!activeId) return;
  const n = index.notes.find(x=>x.id===activeId);
  if (!n) return;
  const title = prompt("–ù–æ–≤–æ–µ –Ω–∞–∑–≤–∞–Ω–∏–µ:", n.title || ("Note "+n.id));
  if (title === null) return;
  n.title = title.trim() || ("Note "+n.id);
  n.updated = Date.now();
  try{
    await saveIndexTransactional(index, true);
    toast("ok","–ü–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞–Ω–æ");
    renderNotes();
    el("activeTitle").textContent = n.title;
  }catch(e){
    toast("bad","–ù–µ —É–¥–∞–ª–æ—Å—å –ø–µ—Ä–µ–∏–º–µ–Ω–æ–≤–∞—Ç—å", String(e.message||e));
  }
}

async function deleteActive(){
  if (!activeId) return;
  const n = index.notes.find(x=>x.id===activeId);
  if (!n) return;
  if (!confirm(`–£–¥–∞–ª–∏—Ç—å "${n.title}"?`)) return;

  try{
    // remove note chunks
    await deleteBlob((rev,i)=>kNoteChunk(n.id, rev, i), n.rev, n.chunks);

    // remove from index
    index.notes = index.notes.filter(x=>x.id!==n.id);
    await saveIndexTransactional(index, true);

    activeId = null;
    el("editor").value = "";
    el("editor").disabled = true;
    el("btnSave").disabled = true;
    el("btnRename").disabled = true;
    el("btnDelete").disabled = true;
    el("activeTitle").textContent = "‚Äî";
    el("activeMeta").textContent = "‚Äî";
    markDirty(false);

    toast("ok","–£–¥–∞–ª–µ–Ω–æ");
    await refreshUsagePill();
    renderNotes();
  }catch(e){
    toast("bad","–ù–µ —É–¥–∞–ª–æ—Å—å —É–¥–∞–ª–∏—Ç—å", String(e.message||e));
  }
}

async function saveActiveNote(silent=false){
  if (!activeId) return;
  const n = index.notes.find(x=>x.id===activeId);
  if (!n) return;

  const text = el("editor").value;
  const bytes = new TextEncoder().encode(text);

  // estimate chunks
  const needChunks = Math.max(1, Math.ceil(bytes.length / MAX_PLAINTEXT_CHUNK_BYTES));

  // SPACE CHECK: –≤ –º–æ–º–µ–Ω—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –º—ã –¥–µ—Ä–∂–∏–º —Å—Ç–∞—Ä—É—é —Ä–µ–≤–∏–∑–∏—é + –Ω–æ–≤—É—é.
  const usedKeys = (await cloudKeys()).filter(k=>k.startsWith(P)).length;
  const peak = usedKeys + needChunks; // –Ω–æ–≤–∞—è —Ä–µ–≤–∏–∑–∏—è –¥–æ–±–∞–≤–∏—Ç needChunks –∫–ª—é—á–µ–π
  if (peak > CLOUD_MAX_KEYS){
    toast("warn","–ó–∞–ø–∏—Å—å –Ω–µ —Å–æ—Ö—Ä–∞–Ω–∏—Ç—Å—è: –º–∞–ª–æ –º–µ—Å—Ç–∞",
      `–ù—É–∂–Ω–æ –µ—â—ë ${needChunks} keys. Peak = ${peak}/${CLOUD_MAX_KEYS}. –£–¥–∞–ª–∏ –±–æ–ª—å—à–∏–µ –∑–∞–º–µ—Ç–∫–∏ –∏–ª–∏ —á–∞—Å—Ç—å –¥–∞–Ω–Ω—ã—Ö.`);
    return;
  }

  try{
    const newRev = (n.rev || 0) + 1;

    // write new revision
    const newChunks = await saveBlob((rev,i)=>kNoteChunk(n.id, rev, i), newRev, bytes, true);

    // update index first (so note points to new data)
    const oldRev = n.rev, oldChunks = n.chunks;
    n.rev = newRev;
    n.chunks = newChunks;
    n.bytes = bytes.length;
    n.updated = Date.now();

    await saveIndexTransactional(index, true);

    // cleanup old revision (best effort)
    if (oldRev && oldChunks){
      await deleteBlob((rev,i)=>kNoteChunk(n.id, rev, i), oldRev, oldChunks);
    }

    markDirty(false);
    el("activeMeta").textContent = `#${n.id} ¬∑ ${fmtBytes(n.bytes||0)} ¬∑ ${n.chunks} chunks ¬∑ rev ${n.rev}`;
    if (!silent) toast("ok","–°–æ—Ö—Ä–∞–Ω–µ–Ω–æ", `${fmtBytes(bytes.length)} ¬∑ ${newChunks} chunks`);
    await refreshUsagePill();
    renderNotes();
  }catch(e){
    toast("bad","–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è", String(e.message||e));
  }
}

/* =========================
   Unlock / Lock
   ========================= */
function showModal(on){
  el("lockModal").classList.toggle("on", !!on);
  if (on){
    el("pw").value = "";
    el("pw").focus();
  }
}
async function doUnlock(){
  const password = el("pw").value;
  el("unlockHint").textContent = "";
  if (!password || password.length < 4){
    el("unlockHint").innerHTML = "<span class='tag-warn'>–ü–∞—Ä–æ–ª—å —Å–ª–∏—à–∫–æ–º –∫–æ—Ä–æ—Ç–∫–∏–π.</span>";
    return;
  }
  try{
    const salt = await getOrCreateSalt();
    vaultKey = await deriveKeyFromPassword(password, salt);

    // Try load meta; if missing -> init new vault
    let m = await loadMeta().catch(()=>null);
    if (!m){
      meta = { metaRev: 1, indexRev: 1, indexChunks: 1 };

      // empty index
      index = { version:1, nextId: 1, notes: [] };
      const idxBytes = new TextEncoder().encode(JSON.stringify(index));

      // save index rev=1
      const chunks = await saveBlob((rev,i)=>kIndexChunk(rev,i), 1, idxBytes, true);
      meta.indexChunks = chunks;
      await saveMeta(meta);

      toast("ok","–°–æ–∑–¥–∞–Ω –Ω–æ–≤—ã–π vault");
    }else{
      meta = m;
      index = await loadIndex(); // decrypt index using derived key
      toast("ok","Vault —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω", `${index.notes.length} notes`);
    }

    setLockedUI(true);
    showModal(false);

    // enable UI
    el("q").value = "";
    activeId = null;
    renderNotes();
    await refreshUsagePill();
    startAutosave();
  }catch(e){
    vaultKey = null;
    meta = null;
    index = { version:1, nextId:1, notes:[] };
    setLockedUI(false);
    el("unlockHint").innerHTML = "<span class='tag-bad'>–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å –∏–ª–∏ –¥–∞–Ω–Ω—ã–µ –ø–æ–≤—Ä–µ–∂–¥–µ–Ω—ã.</span>";
    toast("bad","–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞–∑–±–ª–æ–∫–∏—Ä–æ–≤–∞—Ç—å", String(e.message||e));
  }
}

function doLock(){
  vaultKey = null;
  meta = null;
  index = { version:1, nextId:1, notes:[] };
  activeId = null;
  markDirty(false);
  setLockedUI(false);
  renderNotes();
  refreshUsagePill();
  toast("ok","–ó–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω–æ");
}

/* =========================
   Export / Clear
   ========================= */
async function doExport(){
  if (!unlocked) return;
  // –≠–∫—Å–ø–æ—Ä—Ç–∏—Ä—É–µ–º —Ç–æ–ª—å–∫–æ index (–∑–∞–≥–æ–ª–æ–≤–∫–∏ + –º–µ—Ç–∞) –∏ –≤—Å–µ –∑–∞–º–µ—Ç–∫–∏ (–≤ plaintext) –≤ –æ–¥–∏–Ω JSON.
  // (–≠—Ç–æ –¥–ª—è —É–¥–æ–±—Å—Ç–≤–∞. –•–æ—á–µ—à—å ‚Äî –º–æ–∂–Ω–æ —É–±—Ä–∞—Ç—å plaintext —ç–∫—Å–ø–æ—Ä—Ç.)
  try{
    const dump = {
      exportedAt: new Date().toISOString(),
      notes: []
    };
    for (const n of index.notes){
      const bytes = await loadBlob((rev,i)=>kNoteChunk(n.id, rev, i), n.rev, n.chunks);
      const txt = new TextDecoder().decode(bytes);
      dump.notes.push({
        id: n.id,
        title: n.title,
        updated: n.updated,
        text: txt
      });
    }
    const blob = new Blob([JSON.stringify(dump, null, 2)], {type:"application/json"});
    const url = URL.createObjectURL(blob);
    const a = document.createElement("a");
    a.href = url;
    a.download = "vault-export.json";
    a.click();
    URL.revokeObjectURL(url);
    toast("ok","–≠–∫—Å–ø–æ—Ä—Ç –≥–æ—Ç–æ–≤");
  }catch(e){
    toast("bad","–ù–µ —É–¥–∞–ª–æ—Å—å —ç–∫—Å–ø–æ—Ä—Ç–∏—Ä–æ–≤–∞—Ç—å", String(e.message||e));
  }
}

async function clearVault(){
  if (!confirm("–¢–û–ß–ù–û –æ—á–∏—Å—Ç–∏—Ç—å vault? –≠—Ç–æ —É–¥–∞–ª–∏—Ç –í–°–ï –∫–ª—é—á–∏ cs1_*.")) return;
  try{
    const keys = (await cloudKeys()).filter(k => k.startsWith(P));
    for (const k of keys) await cloudRemove(k);
    doLock();
    toast("ok","Vault –æ—á–∏—â–µ–Ω");
  }catch(e){
    toast("bad","–û—à–∏–±–∫–∞ –æ—á–∏—Å—Ç–∫–∏", String(e.message||e));
  }
}

/* =========================
   Wire up events
   ========================= */
el("btnUnlock").onclick = ()=> showModal(true);
el("btnCloseModal").onclick = ()=> showModal(false);
el("btnDoUnlock").onclick = doUnlock;
el("pw").addEventListener("keydown", (e)=>{ if (e.key==="Enter") doUnlock(); });

el("btnLock").onclick = doLock;
el("btnNew").onclick = createNewNote;
el("btnRename").onclick = renameActive;
el("btnDelete").onclick = deleteActive;
el("btnSave").onclick = ()=>saveActiveNote(false);
el("btnExport").onclick = doExport;
el("btnClear").onclick = clearVault;

el("q").addEventListener("input", ()=>renderNotes());

el("editor").addEventListener("input", ()=>{
  if (!unlocked || !activeId) return;
  markDirty(true);
  updateEditorInfo();
  // debounce hint
  if (autosaveTimer) { /* autosave interval handles */ }
});

document.addEventListener("keydown", (e)=>{
  if ((e.ctrlKey || e.metaKey) && e.key.toLowerCase()==="s"){
    e.preventDefault();
    if (unlocked && activeId) saveActiveNote(false);
  }
});

// Initial state
setLockedUI(false);
renderNotes();
refreshUsagePill();

// If not in Telegram, show a hint once
if (!hasCloud()){
  toast("warn","CloudStorage –Ω–µ –Ω–∞–π–¥–µ–Ω",
    "–û—Ç–∫—Ä—ã–ª—Å—è fallback –Ω–∞ localStorage (–¥–ª—è —Ç–µ—Å—Ç–∞ –≤ –æ–±—ã—á–Ω–æ–º –±—Ä–∞—É–∑–µ—Ä–µ). –í Telegram –±—É–¥–µ—Ç CloudStorage.");
}
</script>
</body>
</html>
